# リフレクションシステム

オブジェクト作成の抽象化、コピー、クローン、スクリプトからのアクセスのための登録処理をまとめて一つのコードで済ますために、リフレクションシステムを実装する。  

## 機能

- コピー
- クローン
- boost::ptreeからの読み込み
- ObjectTypeIDや型情報からのオブジェクト作成
- オブジェクトの情報取得(未実装)
- Luaスクリプトへのバインド(未実装)

## 登録できる要素

- クラス(抽象クラスも含める)
    - メンバ関数
    - メンバ変数
    - プロパティ(ゲッタとセッタを登録することで実現)
    - 読み取り専用プロパティ
    - 書き込み専用プロパティ

## クラスの登録

### 登録可能なクラスの要件

- Reflectableを継承している

### 登録方法

クラス宣言の後ろにマクロ

    PE_REGISTER_OBJECT

でクラス名を指定することで、リフレクションシステムに登録される。

また、レフレクション情報を設定するには登録したいクラスCの公開静的メンバ関数として、

    static void ReflectionDataRegisterer(ClassRegisterer<C>& registerer);

を定義する。この関数内で、引数のClassRegisterを用いてクラスの各情報を登録していく。  

親クラスを指定するためには、公開Superエイリアスを定義すればよい。

## クラスメンバの登録

### 登録可能な型の要件

- 代入演算子が定義されている

要件を満たしていなくても登録することはできるが、今のところはアクセスすることができない。

## クラスメンバのコピー指定

### 登録可能な型の要件

ShallowCopy対象にするためにはReflectableを継承しているか代入演算子が定義されていること、DeepCopy対象に登録するためには関節参照演算子が定義されていて、その戻り値の型がReflectableを継承しているか代入演算子が定義されていることが必要になる。

要件を満たしていない場合はコンパイルエラーになる。

### コピーの挙動

コピー代入可能なクラスは代入演算子によりコピーされる。
コピー代入不可能でリフレクションシステムに登録されているクラスは、リフレクション情報をもとにコピーされる。

### コピーしなくてもよいもの

GameObjectComponentにおいて、OnInitializedやOnActivated内で初期化を行うものは、コピーしても意味がないのでコピー対象にする必要はない。

## クラスメンバのPtreeからの読み込み

### 登録可能な型の要件

Reflectableを継承していてリフレクションシステムに登録しているか、STLコンテナクラスであるか、ptree::get_value<T>がコンパイル可能な型である必要がある。

ポインタ型などには対応していない。

### 要件を満たしていない型

要件を満たしていない場合でもコンパイルエラーにはならないが、要件を満たしていない型の要素を読み込もうとした際には、実行時エラーとしてreflection_errorが送出される。

### 型の変換関数登録

planeta::util名前空間に、void ReflectivePtreeConverter(T& dst, const boost::property_tree::ptree& src)の定義を追加することで可能。

## リフレクションシステムへのアクセス

planeta名前空間のReflectionクラスに定義されている静的関数群から利用できる。

## コピーとクローン

登録された情報をもとに、

## Luaスクリプトへのバインド

登録した情報のうち、特に指定されていないものはLuaへ公開される。

## エラー処理について

基本的に、reflection_error例外により行う。

## ReflectionAccessibleクラス

リフレクションへのアクセス関数を追加するためのクラス。内部でリフレクション用クラス情報を保持するため、少しメモリを消費する。
毎回リフレクション情報の検索を行うReflectionクラスを介したアクセスよりも、リフレクションデータへのアクセスは高速になる。

## 注意事項

### Reflectableクラスの変数、コピー対象登録

クラスメンバや、コピー対象としてReflectableクラスを登録することには対応しているが、まだ不完全である。

### 原因不明の重複登録エラーが出る場合

PlanetaEngineとそれを利用するプロジェクトをリビルドしてみると治る可能性がある。

### GameObjectComponentについて

登録するコピーハンドラ、または変数の代入演算子ないで、ほかのコンポーネントに対する操作は行ってはいけない。
GOCのクローン処理はGetOtherComponentsProc前に事項されるため、Clone時にはほかのコンポーネントを取得できておらず参照できないため。